# 인덱스 설정을 위한 사용하는 쿼리 및 분석

##	콘서트 조회 
1. Concert 엔티티와 관련된 ConcertDate 엔티티를 함께 조회
##	콘서트 날짜 조회
1. Date 값에 해당하는 ConcertDate 엔티티 조회
##	좌석 조회
1. 중복 제거를 위한 DISTINCT 쿼리

	쿼리: concert_date 테이블에서 특정 ConcertDate_id에 해당하는 레코드와 이와 연결된 seat 테이블의 정보를 LEFT JOIN을 통해 가져옵니다. 결과에서 중복된 ConcertDate_id를 제거하여 고유한 값만을 리스트로 만듭니다.

3. 상세 정보 조회 쿼리
   
	쿼리: concert_date 테이블과 seat 테이블을 ConcertDate_id를 기준으로 LEFT JOIN하여, 특정 공연 날짜와 그에 연결된 좌석 정보를 함께 조회합니다. 여기서도 특정 ConcertDate_id를 조건으로 사용하여 정확한 정보를 필터링합니다.

4. 좌석 정보 필터링 쿼리

	쿼리: seat 테이블과 concert_date 테이블을 JOIN하여, 특정 공연 날짜에 해당하는 좌석 정보를 가져옵니다. status를 조건으로 사용하여, 해당 조건을 만족하는 좌석만을 조회합니다.

##	좌석 예약
1. 좌석 정보 조회 쿼리:
   
	쿼리: Seat 테이블에서 좌석 정보와 관련된 ConcertDate, Concert 정보를 LEFT JOIN으로 연결하여 모든 관련 데이터를 조회합니다.
   
2. 예약 정보 조회 쿼리:
   
	쿼리: Reservation 테이블에서 주어진 id에 해당하는 예약 상세 정보를 조회합니다.
   
3. 트랜잭션 시작:
   
	쿼리: 데이터베이스에서 여러 작업을 원자적으로 처리하기 위해 트랜잭션을 시작합니다.
   
4. 예약 정보 입력 쿼리:
    
	쿼리: 주어진 데이터를 바탕으로 새로운 예약 레코드를 추가합니다.
    
5. 트랜잭션 커밋:

	쿼리: 모든 쿼리 작업이 성공적으로 완료되었으면, 트랜잭션을 커밋하여 변경 사항을 데이터베이스에 확정합니다.

6. 좌석 상태 업데이트 쿼리:
   
	쿼리: Seat 테이블에서 주어진 id의 좌석 status를 'reserved'로 업데이트합니다.
   
7. 공연 날짜별 사용 가능 좌석 업데이트 쿼리:
   
	쿼리: ConcertDate 테이블에서 해당 공연 날짜의 사용 가능 좌석 수를 감소시킵니다.

##	결제
1. 트랜잭션 시작

	목적: 데이터베이스에서 여러 작업을 원자적으로 처리하기 위해 트랜잭션을 시작합니다.

3. 예약 정보의 일관성 있는 조회
   
	쿼리: Reservation 테이블에서 예약 정보와 관련된 Seat 정보를 조회합니다. 이 쿼리는 데이터의 일관성을 유지하기 위해 FOR UPDATE 절을 사용하여 조회 중인 데이터에 대한 잠금을 설정하여 변경을 방지합니다.
   
3. 사용자 정보의 일관성 있는 조회
   
	쿼리: 특정 사용자의 정보를 조회하면서 FOR UPDATE 절을 사용하여 이 사용자에 대한 잠금을 설정합니다.

4. 사용자 포인트 업데이트

	쿼리: 사용자의 포인트 정보를 업데이트합니다. 예약을 위한 결제 과정으로 사용자의 포인트가 차감됩니다.

5. 포인트 이력 기록
   
	쿼리: 사용자의 포인트 변경 사항을 point_history 테이블에 기록합니다. 이 기록은 포인트 차감 또는 적립을 추적하기 위한 것입니다.

6. 예약 상태 업데이트

	쿼리: 특정 예약의 paymentCompleted 필드를 업데이트하여 결제 완료 상태를 반영합니다.

7. 좌석 상태 업데이트

	쿼리: 특정 좌석의 status를 held로 변경합니다.좌석이 예약된 상태임을 나타내기 위해 사용됩니다.

8. 트랜잭션 커밋

	목적: 모든 데이터베이스 작업이 정상적으로 완료되었을 경우, 이를 확정하여 변경 사항을 데이터베이스에 반영합니다. 만약 중간에 오류가 발생했다면, 트랜잭션을 롤백하여 시작 전 상태로 복구합니다.

##	포인트 충전
1. 트랜잭션 시작
   
	목적: 데이터의 일관성과 정합성을 보장하기 위해 여러 작업을 묶어 한 번에 처리합니다. 오류 발생 시 전체 작업을 롤백할 수 있도록 합니다.

2. 사용자 정보 조회

	쿼리: 사용자 테이블에서 id값에 해당하는 정보를 조회합니다. FOR UPDATE 절은 해당 사용자에 대한 정보를 잠금하여 다른 트랜잭션이 동시에 같은 데이터를 변경하지 못하게 합니다.

3. 사용자 포인트 업데이트
   
	쿼리: 조회된 사용자의 포인트를 기존 point에서 변경된 값으로 업데이트합니다.

4. 포인트 이력 조회
   
	쿼리: point_history 테이블에서 특정 포인트 이력을 조회합니다.

5. 포인트 이력 추가

	쿼리: 새로운 포인트 이력을 point_history 테이블에 추가합니다. 이 때, 포인트가 "charge" 이유로 추가되며, created_at은 기본값(현재 시각)으로 설정됩니다.

6. 트랜잭션 커밋

	목적: 모든 쿼리 작업이 성공적으로 완료되면, 트랜잭션을 커밋하여 모든 데이터 변경을 확정하고 데이터베이스에 반영합니다.
    7.	포인트 조회
        •	목적: id값에 해당하는 user 엔티티 조회

# 인덱스 설정

## 콘서트 날짜 테이블
    1. 인덱스 설정
        • 콘서트 날짜 조회는 빈번하게 일어나므로 Date Column을 index로 설정하였습니다.
        • 관계형 데이터 조인 성능 향상을 위해 concert column을 index로 설정하였습니다.
        • 복합 인덱스에서 더 조회가 잦은 테이블을 우선시 둬야하기 때문에 concert column을 우선시합니다.
    2. 성능 체크
        • 성능 체크는 해당 함수가 호출되기 전 console.time('key'), 호출된 후 console.timeEnd('key') 를 사용해 함수 실행 시간 결과를 측정합니다.
        • 처음 함수가 실행 될 때를 기준으로 체크합니다.
        • 기준 데이터의 개수를 1000개로 함
        • 어느 Column도 Index 설정이 되어 있지 않았을 경우 함수 실행 시간 : 56ms
        • Index(date, concert)를 설정 후 함수 실행 시간 : 40ms
        • Index(date, concert)를 따로따로 설정한 후 함수 실행 시간 : 40ms
    3. 결과
        • 콘서트 날짜 조회는 빈번하게 일어나므로 Date Column을 index로 설정하는 것을 근거로 삼았으나, 사실 상 날짜에 해당하는 조회는 콘서트 날짜 등록시 발생하며, 이 후에는 발생하지 않음으로 date에 대한 Index 설정은 비효율적이라는 판단하에 삭제하였습니다.

## 좌석 
    1. 인덱스 설정
        • 관계형 데이터 조인 성능 향상을 위해  concertDate column을 index로 설정하였습니다.
        • 좌석 조회시 status의 ‘available’ 값에 대한 조회가 빈번하므로 index 설정하였습니다.
        • 복합 인덱스에서 더 조회가 잦은 테이블을 우선시 둬야하기 때문에 concertDate column을 우선시합니다.
    2. 성능 체크 
        • 성능 체크는 해당 함수가 호출되기 전 console.time('key'), 호출된 후 console.timeEnd('key') 를 사용해 함수 실행 시간 결과를 측정합니다.
        • 처음 함수가 실행 될 때를 기준으로 체크합니다.
        • 기준 데이터의 개수를 6000개로 함
        • 어느 Column도 Index 설정이 되어 있지 않았을 경우 함수 실행 시간 : 480ms
        • Index(concertDate, status의)를 설정 후 함수 실행 시간 : 250ms
        • Index(concertDate, status의)를 따로따로 설정한 후 함수 실행 시간 : 400ms
    3. 결과
        • 처음 인덱스 설정한 것(concertDate status의 복합 인덱스로 사용)이 성능이 더 우세하므로 그대로 설정
